version: 0.50.2
type: DeclarativeSource

check:
  type: CheckStream
  stream_names:
    - balances

definitions:
  selector:
    type: RecordSelector
    extractor:
      type: DpathExtractor
      field_path:
        - "{{ parameters.field_path }}"

  requester:
    type: HttpRequester
    url_base: 'https://api-m.{{ "sandbox." if config["is_sandbox"] }}paypal.com/'
    path: "{{ parameters.path }}"
    http_method: GET
    request_headers:
      Content-Type: application/json
    authenticator:
      type: CustomAuthenticator
      class_name: source_paypal_transaction.components.PayPalOauth2Authenticator
      client_id: "{{ config['client_id'] }}"
      client_secret: "{{ config['client_secret'] }}"
      refresh_request_body:
        Content-Type: application/x-www-form-urlencoded
      token_refresh_endpoint: 'https://api-m.{{ "sandbox." if config["is_sandbox"] }}paypal.com/v1/oauth2/token'
      grant_type: client_credentials
      expires_in_name: expires_in
      access_token_name: access_token
    error_handler:
      type: CompositeErrorHandler
      error_handlers:
        - type: DefaultErrorHandler
          backoff_strategies:
            - type: ConstantBackoffStrategy
              backoff_time_in_seconds: 100
    request_body_json: {}

  #NOTE: The streams Payments, Orders and Subscriptions require a webhook so you can register
  #the Ids of each event as these endpoints do not have a GET method to list the Ids and use it
  #in other streams

  #Stream Transactions
  #Paypal API only has V1 for this stream
  transactions_stream:
    type: DeclarativeStream
    primary_key: transaction_id
    name: "transactions"
    retriever:
      type: SimpleRetriever
      record_selector:
        $ref: "#/definitions/selector"
      paginator:
        type: DefaultPaginator
        page_token_option:
          type: RequestOption
          inject_into: request_parameter
          field_name: page
        page_size_option:
          inject_into: request_parameter
          field_name: page_size
          type: RequestOption
        pagination_strategy:
          type: PageIncrement
          start_from_page: 1
          page_size: 500
      requester:
        $ref: "#/definitions/requester"
        request_parameters:
          fields: all
        error_handler:
          type: CompositeErrorHandler
          error_handlers: 
            - type: DefaultErrorHandler
              description: "Handle HTTP 400 with error message: Data for the given start date is not available. "
              response_filters:
                - http_codes: [400]
                  action: IGNORE
                  predicate: "{{ 'Data for the given start date is not available' in response['message']}}"
    transformations:
      - type: AddFields
        fields:
          - path:
              - transaction_updated_date
            value: >-
              {{ format_datetime(record['transaction_info']['transaction_updated_date'], '%Y-%m-%dT%H:%M:%SZ') }}
      - type: AddFields
        fields:
          - path:
              - transaction_id
            value: "{{ record['transaction_info']['transaction_id'] }}"
            value_type: string
    incremental_sync:
      type: DatetimeBasedCursor
      cursor_field: transaction_updated_date
      cursor_datetime_formats:
        - "%Y-%m-%dT%H:%M:%SZ"
      datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      start_datetime:
        type: MinMaxDatetime
        datetime: >-
          {{ max( format_datetime(config['start_date'], '%Y-%m-%dT%H:%M:%SZ'), day_delta(-1095, format='%Y-%m-%dT%H:%M:%SZ') ) }}
        datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      start_time_option:
        type: RequestOption
        field_name: start_date
        inject_into: request_parameter
      end_time_option:
        type: RequestOption
        field_name: end_date
        inject_into: request_parameter
      end_datetime:
        type: MinMaxDatetime
        datetime: "{{ now_utc().strftime('%Y-%m-%dT%H:%M:%SZ') }}"
        datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      step: "P{{ config.get('time_window', 7) }}D"
      cursor_granularity: PT1S
    $parameters:
      path: "v1/reporting/transactions"
      field_path: transaction_details
  
  #Stream balances
  #Paypal API only has V1 for this stream
  balances_stream:
    type: DeclarativeStream
    primary_key: as_of_time
    name: "balances"
    retriever:
      type: SimpleRetriever
      record_selector:
        type: RecordSelector
        extractor:
          type: DpathExtractor
          field_path: []
      paginator:
        type: DefaultPaginator
        pagination_strategy:
          type: PageIncrement
          page_size: 500
      requester:
        $ref: "#/definitions/requester"
        request_parameters: {}
    transformations:
      - type: AddFields
        fields:
          - path:
              - as_of_time
            value: "{{ format_datetime(record['as_of_time'], '%Y-%m-%dT%H:%M:%SZ') }}"
    incremental_sync:
      type: DatetimeBasedCursor
      cursor_field: as_of_time
      cursor_datetime_formats:
        - "%Y-%m-%dT%H:%M:%SZ"
      datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      start_datetime:
        type: MinMaxDatetime
        datetime: >-
          {{ max( format_datetime(config['start_date'], '%Y-%m-%dT%H:%M:%SZ'), day_delta(-1095, format='%Y-%m-%dT%H:%M:%SZ') ) }}
        datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      start_time_option:
        type: RequestOption
        field_name: as_of_time
        inject_into: request_parameter
    $parameters:
      path: "v1/reporting/balances"
  
  #New Stream - List Product
  #Paypal API only has V1 for this stream
  list_products_stream:
    type: DeclarativeStream
    primary_key: id
    name: "list_products"
    retriever:
      type: SimpleRetriever
      record_selector:
        $ref: "#/definitions/selector"
      paginator:
        type: DefaultPaginator
        pagination_strategy:
          type: PageIncrement
          start_from_page: 1
          page_size: 20
        page_token_option:
           type: RequestOption
           inject_into: request_parameter
           field_name: page
        page_size_option:
           inject_into: request_parameter
           field_name: page_size
           type: RequestOption
      requester:
        $ref: "#/definitions/requester"
        http_method: GET
        request_headers:
          Content-Type: application/json
    $parameters:
      path: "v1/catalogs/products"
      field_path: products
    
  #Stream List Disputes
  #Paypal API only has V1 for this stream
  #There is no way to create disputes via API, thus no incremental sync will be added to this stream
  #until we have a testing account that allows us to create disputes over transactions.
  list_disputes_stream:
    type: DeclarativeStream
    primary_key: dispute_id
    name: "list_disputes"

    retriever:
      type: SimpleRetriever
      record_selector:
        $ref: "#/definitions/selector"
      paginator:
        type: DefaultPaginator
        page_token_option:
          type: RequestOption
          inject_into: request_parameter
          field_name: next_page_token
        page_size_option:
          inject_into: request_parameter
          field_name: page_size
          type: RequestOption
        pagination_strategy:
            type: PageIncrement
            start_from_page: 1
            page_size: 50
      requester:
        $ref: "#/definitions/requester"
        http_method: GET
        request_parameters: 
          #Searches for the optional parameter dispute_start_date. 
          #If present, it formats the date accordingly. Otherwise, it defaults to a start date set 180 days in the past."
          start_time: "{{ format_datetime(config['dispute_start_date'] if config['dispute_start_date'] else (now_utc() - duration('P179D')), '%Y-%m-%dT%H:%M:%S.%fZ')[:23] + 'Z' }}"
    $parameters:
      path: "v1/customer/disputes"
      field_path: items

  #Stream Search Invoices 
  # Currently it does not support incremental sync as metadata does not contain last_update_date
  # TODO: Review if this is only a sandbox problem
  search_invoices_stream:
    type: DeclarativeStream
    primary_key: id
    name: "search_invoices"
    retriever:
      type: SimpleRetriever
      record_selector:
        $ref: "#/definitions/selector"
      paginator:
        type: DefaultPaginator
        page_token_option:
          type: RequestOption
          inject_into: request_parameter
          field_name: page
        page_size_option:
          inject_into: request_parameter
          field_name: page_size
          type: RequestOption
        pagination_strategy:
          type: PageIncrement
          start_from_page: 1
          page_size: 20
      requester:
        $ref: "#/definitions/requester"
        http_method: POST
        request_headers:
          Content-Type: application/json
        request_body_json:
          creation_date_range:
            start: "{{ config['start_date'] }}"
            end: "{{ now_utc().strftime('%Y-%m-%dT%H:%M:%SZ') }}"    
    $parameters:
      field_path: items
      path: "v2/invoicing/search-invoices"  
  
  #Stream List Payments
  #Currently uses V1 which is about to be derecated
  #But there is no endpoint in v2 for listing payments
  list_payments_stream:
    type: DeclarativeStream
    primary_key: id
    name: "list_payments"
    retriever:
      type: SimpleRetriever
      record_selector:
        $ref: "#/definitions/selector"
      paginator:
        type: DefaultPaginator
        pagination_strategy:
          type: CursorPagination
          cursor_value: "{{ response.next_id}}"
          stop_condition: "{{ response.next_id == ''}}"
          page_size: 20
        page_token_option:
          type: RequestOption
          field_name: start_id
          inject_into: request_parameter
        page_size_option:
          type: RequestOption
          field_name: count
          inject_into: request_parameter
      requester:
        $ref: "#/definitions/requester"
        request_parameters:
          start_time: "{{ stream_interval.start_time.strftime('%Y-%m-%dT%H:%M:%SZ') }}"
          end_time: "{{ stream_interval.end_time.strftime('%Y-%m-%dT%H:%M:%SZ') }}"
    incremental_sync:
      type: DatetimeBasedCursor
      cursor_field: update_time
      datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      start_datetime:
        #type: MinMaxDatetime
        datetime: "{{ config['start_date'] }}"
        datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      end_datetime:
        type: MinMaxDatetime
        datetime: "{{ now_utc().strftime('%Y-%m-%dT%H:%M:%SZ') }}"
        datetime_format: "%Y-%m-%dT%H:%M:%SZ"
      start_time_option:
        type: RequestOption
        field_name: start_time
        inject_into: request_parameter
      end_time_option:
        type: RequestOption
        field_name: end_time
        inject_into: request_parameter
      step: "P1D"
      cursor_granularity: PT1S
    $parameters:
      path: "v1/payments/payment"
      field_path: payments

streams:
  - "#/definitions/transactions_stream"
  - "#/definitions/balances_stream"
  - "#/definitions/list_products_stream"
  - "#/definitions/show_product_details_stream"
  - "#/definitions/list_disputes_stream"
  - "#/definitions/search_invoices_stream"
  - "#/definitions/list_payments_stream"

spec:
  type: Spec
  documentation_url: https://docs.airbyte.com/integrations/sources/paypal-transactions
  connection_specification:
    $schema: http://json-schema.org/draft-07/schema#
    type: object
    additionalProperties: true
    required:
      - client_id
      - client_secret
      - start_date
      - is_sandbox
    properties:
      client_id:
        type: string
        title: Client ID
        description: "The Client ID of your Paypal developer application."
        airbyte_secret: true
        order: 0
      client_secret:
        type: string
        title: Client secret
        description: "The Client Secret of your Paypal developer application."
        airbyte_secret: true
        order: 1
      start_date:
        title: Start Date
        description: >-
          Start Date for data extraction in <a
          href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\">ISO
          format</a>. Date must be in range from 3 years till 12 hrs before
          present time.
        type: string
        examples: ["2021-06-11T23:59:59", "2021-06-11T23:59:59+00:00"]
        pattern: ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(|Z|[+-][0-9]{2}:[0-9]{2})$
        format: "date-time"
        order: 2
      is_sandbox:
        title: "Sandbox"
        description: "Determines whether to use the sandbox or production environment."
        type: "boolean"
        default: false
      dispute_start_date:
        title: Dispute Start Date Range
        description: >-
          Start Date parameter for the list dispute endpoint in <a
          href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\">ISO
          format</a>. This Start Date must be in range within 180 days before
          present time, and requires ONLY 3 miliseconds(mandatory).
          If you don't use this option, it defaults to a start date set 180 days in the past.
        type: string
        examples: ["2021-06-11T23:59:59.000Z"]
        pattern: ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}Z$
        format: "date-time"
        order: 2
      refresh_token:
        type: "string"
        title: "Refresh token"
        description: "The key to refresh the expired access token."
        airbyte_secret: true
      time_window:
        type: "integer"
        title: "Number of days per request"
        description: "The number of days per request. Must be a number between 1 and 31."
        default: 7
        minimum: 1
        maximum: 31
